#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
#include <graphics.h>			// 引用图形库头文件
#include <conio.h>
#include <iostream>
using namespace std;


float wxl, wxr, wyb, wyt;//定义全局变量，方便各函数使用


int cohensutherland(int d[], float& x, float& y, float k)//直线段剪裁函数，根据窗口外的端点和斜率找到线段与窗口边界的交点
{
    if (d[0] == 1)//如果端点在左侧（1001，0001，0101三个区域）
    {
        y = k * (wxl - x) + y;
        x = wxl;//找到线段和x=wxl的交点
    }
    if (d[1] == 1)//如果端点在右侧（1010，0010，0110三个区域）
    {
        y = k * (wxr - x) + y;
        x = wxr;//找到线段和x=wxr的交点
    }
    if ((d[2] == 1) && (d[0] == 0) && (d[1] == 0) && (d[3] == 0))//如果端点在下侧（0100一个区域）
    {
        x = (wyb - y) / k + x;
        y = wyb;//算出线段和窗口下侧边界的交点
    }
    if ((d[3] == 1) && (d[0] == 0) && (d[1] == 0) && (d[2] == 0))//如果端点在上侧（1000一个区域）
    {
        x = (wyt - y) / k + x;
        y = wyt;//算出线段和窗口上侧边界的交点
    }
    return 0;
}


int code(int a[], float x, float y)//对两端点坐标编码
{
    if (x < wxl) a[0] = 1;
    else a[0] = 0;
    if (x > wxr) a[1] = 1;
    else a[1] = 0;
    if (y < wyb) a[2] = 1;
    else a[2] = 0;
    if (y > wyt) a[3] = 1;
    else a[3] = 0;
    return 0;
}


void Acd(float x1,float y1,float x2,float y2,float wxl,float wxr,float wyb,float wyt)
{
    setcolor(RED);
    line(x1, y1, x2, y2);
    setcolor(BLACK);
    line(wxl, wyt, wxl, wyb);
    line(wxl, wyb, wxr, wyb);
    line(wxr, wyb, wxr, wyt);
    line(wxr, wyt, wxl, wyt);
    Sleep(5000);//停留
    cleardevice();//清空屏幕
}
int main()
{
        int d1[4] = { 0,0,0,0 };
        int d2[4] = { 0,0,0,0 };//端点的区域编码，用数组来表示
        float x1, y1, x2, y2;
       cout << "分别输入两点坐标和窗口的四条边界坐标：";
       cout << endl << "x1=";
       cin >> x1;
       cout << "y1=";
       cin >> y1;
       cout << "x2=";
       cin >> x2;
       cout << "y2=";
       cin >> y2;
       cout << "wxl=";
       cin >> wxl;
       cout << "wxr=";
       cin >> wxr;
       cout << "wyb=";
       cin >> wyb;
       cout << "wyt=";
       cin >> wyt;
    initgraph(800, 700);
    // 设置背景色为蓝色
    setbkcolor(GREEN);
    // 用背景色清空屏幕
    cleardevice();
    setorigin(320, 240);//设置坐标原点
    setaspectratio(1, -1); //可使 y 轴向上为正
    Acd(x1, y1, x2, y2, wxl, wxr, wyb, wyt);
    while (1)
    {
        code(d1, x1, y1);//对端点p1进行区域编码
        code(d2, x2, y2);//对端点p2进行区域编码
        if ((d1[0] == 0) && (d1[1] == 0) && (d1[2] == 0) && (d1[3] == 0) && (d2[0] == 0) && (d2[1] == 0) && (d2[2] == 0) && (d2[3] == 0))//code1|code2=0
        {
           
            cout << "在窗口内的两点坐标：" << "(" << x1 << "," << y1 << ")" << "(" << x2 << "," << y2 << ")";

            Acd(x1, y1, x2, y2, wxl, wxr, wyb, wyt);
            break;
        }
        else if ((d1[0] & d2[0]) | (d1[1] & d2[1]) | (d1[2] & d2[2]) | (d1[3] & d1[3]))//code1&code2=1
        {
            closegraph();			// 关闭图形界面
            cout << "直线段在窗口外"; break;
        }
        else//和边界有交点（实交点和虚交点）
        {
            float k = (y2 - y1) / (x2 - x1);
            if (!(d1[0] | d1[1] | d1[2] | d1[3]))//p1点在窗口内，则交换p1和p2的坐标值和编码值
            {
                float x, y;
                int t, i;
                x = x2; x2 = x1; x1 = x;
                y = y2; y2 = y1; y1 = y;
                for (i = 0; i <= 3; i++)
                {
                    t = d2[i];
                    d2[i] = d1[i];
                    d1[i] = t;
                }
            }
            cohensutherland(d1, x1, y1, k);//对p1进行裁剪
        }
    }

    return 0;
}
